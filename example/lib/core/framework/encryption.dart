import 'dart:convert' as convert;
import 'dart:convert';

import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';
import 'package:pointycastle/api.dart';
import 'package:pointycastle/block/aes.dart';
import 'package:pointycastle/block/modes/gcm.dart';
import 'package:pointycastle/key_derivators/api.dart';
import 'package:pointycastle/key_derivators/pbkdf2.dart';

class EncryptionService {
  static final key = Key.fromUtf8('1234567890123456');
  static final iv = IV.fromUtf8('1234567890123456');

  static String encryptData(String plainText) {
    final encryptor = Encrypter(AES(key, mode: AESMode.cbc));
    final encrypted = encryptor.encrypt(plainText, iv: iv);
    return encrypted.base64;
  }

  static String encryptJsonData(Map<String, dynamic> data) {
    final jsonString = jsonEncode(data);
    return encryptData(jsonString);
  }
}

Uint8List decodeHexString(String input) {
  assert(input.length % 2 == 0, 'Input needs to be an even length.');

  return Uint8List.fromList(
    List.generate(
      input.length ~/ 2,
      (i) => int.parse(input.substring(i * 2, (i * 2) + 2), radix: 16),
    ).toList(),
  );
}

/// Represents an encripted value.
class Encrypted {
  /// Creates an Encrypted object from a Uint8List.
  Encrypted(this._bytes);

  final Uint8List _bytes;

  /// Creates an Encrypted object from a hexdecimal string.
  Encrypted.fromBase16(String encoded) : _bytes = decodeHexString(encoded);

  /// Creates an Encrypted object from a Base64 string.
  Encrypted.fromBase64(String encoded)
      : _bytes = convert.base64.decode(encoded);

  /// Creates an Encrypted object from a Base64 string.
  Encrypted.from64(String encoded) : _bytes = convert.base64.decode(encoded);

  /// Creates an Encrypted object from a UTF-8 string.
  Encrypted.fromUtf8(String input)
      : _bytes = Uint8List.fromList(convert.utf8.encode(input));

  /// Creates an Encrypted object from a length.
  /// The key is filled with [length] bytes generated by a
  /// Random.secure() generator
  Encrypted.fromLength(int length) : _bytes = SecureRandom().nextBytes(length);

  /// Creates an Encrypted object from a length.
  /// The key is filled with [length] bytes generated by a
  /// Random.secure() generator
  Encrypted.fromSecureRandom(int length)
      : _bytes = SecureRandom().nextBytes(length);

  /// Creates an Encrypted object of ALL ZEROS from a length.
  /// The key is ALL ZEROS - NOT CRYPTOGRAPHICALLY SECURE!
  Encrypted.allZerosOfLength(int length) : _bytes = Uint8List(length);

  /// Gets the Encrypted bytes.
  Uint8List get bytes => _bytes;

  /// Gets the Encrypted bytes as a Hexdecimal representation.
  String get base16 =>
      _bytes.map((byte) => byte.toRadixString(16).padLeft(2, '0')).join();

  /// Gets the Encrypted bytes as a Base64 representation.
  String get base64 => convert.base64.encode(_bytes);

  @override
  bool operator ==(other) {
    if (other is Encrypted) {
      return const ListEquality().equals(bytes, other.bytes);
    }

    return false;
  }

  @override
  int get hashCode => ListEquality().hash(bytes);
}

/// Represents an Initialization Vector.
class IV extends Encrypted {
  /// Creates an Initialization Vector object from a Uint8List.
  IV(Uint8List bytes) : super(bytes);

  /// Creates an Initialization Vector object from a hexdecimal string.
  IV.fromBase16(String encoded) : super.fromBase16(encoded);

  /// Creates an Initialization Vector object from a Base64 string.
  IV.fromBase64(String encoded) : super.fromBase64(encoded);

  /// Creates an Initialization Vector object from a UTF-8 string.
  IV.fromUtf8(String input) : super.fromUtf8(input);

  /// Creates an Initialization Vector object from a length.
  /// The key is filled with [length] bytes generated by a
  /// Random.secure() generator
  IV.fromLength(int length) : super.fromLength(length);

  /// Creates an Initialization Vector object from a length.
  /// The key is filled with [length] bytes generated by a
  /// Random.secure() generator
  IV.fromSecureRandom(int length) : super(SecureRandom().nextBytes(length));

  /// Creates an Initialization Vector object of ALL ZEROS from a length.
  /// The key is ALL ZEROS - NOT CRYPTOGRAPHICALLY SECURE!
  IV.allZerosOfLength(int length) : super.allZerosOfLength(length);
}

/// Represents an Encryption Key.
class Key extends Encrypted {
  /// Creates an Encryption Key object from a Uint8List.
  Key(Uint8List bytes) : super(bytes);

  /// Creates an Encryption Key object from a hexdecimal string.
  Key.fromBase16(String encoded) : super.fromBase16(encoded);

  /// Creates an Encryption Key object from a Base64 string.
  Key.fromBase64(String encoded) : super.fromBase64(encoded);

  /// Creates an Encryption Key object from a UTF-8 string.
  Key.fromUtf8(String input) : super.fromUtf8(input);

  /// Creates an Encryption Key object from a length.
  /// The key is filled with [length] bytes generated by a
  /// Random.secure() generator
  Key.fromLength(int length) : super.fromLength(length);

  /// Creates an Encryption Key object from a length.
  /// The key is filled with [length] bytes generated by a
  /// Random.secure() generator
  Key.fromSecureRandom(int length) : super(SecureRandom().nextBytes(length));

  /// Creates an Encryption Key object of ALL ZEROS from a length.
  /// The key is ALL ZEROS - NOT CRYPTOGRAPHICALLY SECURE!
  Key.allZerosOfLength(int length) : super.allZerosOfLength(length);

  Key stretch(int desiredKeyLength,
      {int iterationCount = 100, Uint8List? salt}) {
    salt ??= SecureRandom().nextBytes(desiredKeyLength);

    final params = Pbkdf2Parameters(salt, iterationCount, desiredKeyLength);
    final pbkdf2 = PBKDF2KeyDerivator(Mac('SHA-1/HMAC'))..init(params);

    return Key(pbkdf2.process(_bytes));
  }

  int get length => bytes.lengthInBytes;
}

/// Wraps the AES Algorithm.
class AES implements Algorithm {
  final Key key;
  final AESMode mode;
  final String? padding;
  late final BlockCipher _cipher;
  final StreamCipher? _streamCipher;

  AES(this.key, {this.mode = AESMode.sic, this.padding = 'PKCS7'})
      : _streamCipher = padding == null && _streamable.contains(mode)
            ? StreamCipher('AES/${_modes[mode]}')
            : null {
    if (mode == AESMode.gcm) {
      _cipher = GCMBlockCipher(AESEngine());
    } else {
      _cipher = padding != null
          ? PaddedBlockCipher('AES/${_modes[mode]}/$padding')
          : BlockCipher('AES/${_modes[mode]}');
    }
  }

  @override
  Encrypted encrypt(Uint8List bytes, {IV? iv, Uint8List? associatedData}) {
    if (mode != AESMode.ecb && iv == null) {
      throw StateError('IV is required.');
    }

    if (_streamCipher != null) {
      _streamCipher
        ..reset()
        ..init(true, _buildParams(iv, associatedData: associatedData));

      return Encrypted(_streamCipher.process(bytes));
    }

    _cipher
      ..reset()
      ..init(true, _buildParams(iv, associatedData: associatedData));

    if (padding != null) {
      return Encrypted(_cipher.process(bytes));
    }

    return Encrypted(_processBlocks(bytes));
  }

  @override
  Uint8List decrypt(Encrypted encrypted, {IV? iv, Uint8List? associatedData}) {
    if (mode != AESMode.ecb && iv == null) {
      throw StateError('IV is required.');
    }

    if (_streamCipher != null) {
      _streamCipher
        ..reset()
        ..init(false, _buildParams(iv, associatedData: associatedData));

      return _streamCipher.process(encrypted.bytes);
    }

    _cipher
      ..reset()
      ..init(false, _buildParams(iv, associatedData: associatedData));

    if (padding != null) {
      return _cipher.process(encrypted.bytes);
    }

    return _processBlocks(encrypted.bytes);
  }

  Uint8List _processBlocks(Uint8List input) {
    var output = Uint8List(input.lengthInBytes);

    for (int offset = 0; offset < input.lengthInBytes;) {
      offset += _cipher.processBlock(input, offset, output, offset);
    }

    return output;
  }

  CipherParameters _buildParams(IV? iv, {Uint8List? associatedData}) {
    if (mode == AESMode.ecb || iv == null) {
      if (padding != null) {
        return PaddedBlockCipherParameters(KeyParameter(key.bytes), null);
      } else {
        return KeyParameter(key.bytes);
      }
    }

    if (mode == AESMode.gcm) {
      return AEADParameters(
        KeyParameter(key.bytes),
        128,
        iv.bytes,
        associatedData ?? Uint8List.fromList([]),
      );
    }

    if (padding != null) {
      return _paddedParams(iv);
    }

    return ParametersWithIV<KeyParameter>(KeyParameter(key.bytes), iv.bytes);
  }

  PaddedBlockCipherParameters _paddedParams(IV iv) {
    if (mode == AESMode.ecb) {
      return PaddedBlockCipherParameters(KeyParameter(key.bytes), null);
    }

    return PaddedBlockCipherParameters(
        ParametersWithIV<KeyParameter>(KeyParameter(key.bytes), iv.bytes),
        null);
  }
}

enum AESMode {
  cbc,
  cfb64,
  ctr,
  ecb,
  ofb64Gctr,
  ofb64,
  sic,
  gcm,
}

const Map<AESMode, String> _modes = {
  AESMode.cbc: 'CBC',
  AESMode.cfb64: 'CFB-64',
  AESMode.ctr: 'CTR',
  AESMode.ecb: 'ECB',
  AESMode.ofb64Gctr: 'OFB-64/GCTR',
  AESMode.ofb64: 'OFB-64',
  AESMode.sic: 'SIC',
  AESMode.gcm: 'GCM',
};

const List<AESMode> _streamable = [
  AESMode.sic,
  AESMode.ctr,
];

/// Interface for the Algorithms.
abstract class Algorithm {
  /// Encrypt [bytes].
  Encrypted encrypt(Uint8List bytes, {IV? iv, Uint8List? associatedData});

  /// Decrypt [encrypted] value.
  Uint8List decrypt(Encrypted encrypted, {IV? iv, Uint8List? associatedData});
}

/// Interface for the signing algorithms
abstract class SignerAlgorithm {
  /// Sign [bytes].
  Encrypted sign(Uint8List bytes);

  /// Verify [encrypted] signature.
  bool verify(Uint8List bytes, Encrypted encrypted);
}

/// Wraps Algorithms in a unique Container.
class Encrypter {
  final Algorithm algo;

  Encrypter(this.algo);

  /// Calls [encrypt] on the wrapped Algorithm using a raw binary.
  Encrypted encryptBytes(List<int> input, {IV? iv, Uint8List? associatedData}) {
    if (input is Uint8List) {
      return algo.encrypt(input, iv: iv, associatedData: associatedData);
    }

    return algo.encrypt(
      Uint8List.fromList(input),
      iv: iv,
      associatedData: associatedData,
    );
  }

  /// Calls [encrypt] on the wrapped Algorithm.
  Encrypted encrypt(
    String input, {
    IV? iv,
    Uint8List? associatedData,
  }) {
    return encryptBytes(
      convert.utf8.encode(input),
      iv: iv,
      associatedData: associatedData,
    );
  }

  /// Calls [decrypt] on the wrapped Algorith without UTF-8 decoding.
  List<int> decryptBytes(Encrypted encrypted,
      {IV? iv, Uint8List? associatedData}) {
    return algo
        .decrypt(encrypted, iv: iv, associatedData: associatedData)
        .toList();
  }

  /// Calls [decrypt] on the wrapped Algorithm.
  String decrypt(
    Encrypted encrypted, {
    IV? iv,
    Uint8List? associatedData,
  }) {
    return convert.utf8.decode(
      decryptBytes(encrypted, iv: iv, associatedData: associatedData),
      allowMalformed: true,
    );
  }

  /// Sugar for `decrypt(Encrypted.fromBase16(encoded))`.
  String decrypt16(String encoded, {IV? iv, Uint8List? associatedData}) {
    return decrypt(
      Encrypted.fromBase16(encoded),
      iv: iv,
      associatedData: associatedData,
    );
  }

  /// Sugar for `decrypt(Encrypted.fromBase64(encoded))`.
  String decrypt64(String encoded, {IV? iv, Uint8List? associatedData}) {
    return decrypt(
      Encrypted.fromBase64(encoded),
      iv: iv,
      associatedData: associatedData,
    );
  }
}
